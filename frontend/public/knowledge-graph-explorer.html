<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Knowledge Graph Explorer</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; background-color: #f7f9fc; color: #333; }
    .container { display: flex; height: 100vh; flex-direction: column; }
    .header { background-color: #2c3e50; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
    .header h1 { margin: 0; font-size: 20px; }
    .file-controls { display: flex; align-items: center; }
    .main-container { display: flex; flex: 1; overflow: hidden; }
    .sidebar { width: 280px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 15px; overflow-y: auto; display: flex; flex-direction: column; }
    .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .graph-container { flex: 1; background-color: #fff; margin: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); position: relative; overflow: hidden; }
    .details-panel { height: 230px; background-color: #fff; margin: 0 10px 10px 10px; padding: 15px; box-shadow: 0 0 10px rgba(0,0,0,0.1); overflow-y: auto; }
    .entity-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
    .entity-item { padding: 10px; margin-bottom: 5px; background-color: #f8f9fa; border-left: 3px solid #6c757d; cursor: pointer; border-radius: 3px; transition: all 0.2s; }
    .entity-item:hover { background-color: #e9ecef; transform: translateX(2px); }
    .entity-item.selected { background-color: #e3f2fd; border-left-color: #1976d2; }
    .entity-type { font-size: 11px; color: #666; margin-top: 3px; }
    #search-box { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; box-sizing: border-box; }
    h3 { color: #2c3e50; margin-top: 10px; margin-bottom: 10px; font-size: 16px; }
    .details-title { display: flex; justify-content: space-between; align-items: center; }
    .details-title h3 { margin: 0; }
    .detail-type { font-size: 12px; color: #666; font-style: italic; }
    .property { margin-bottom: 8px; }
    .property-name { font-weight: bold; font-size: 13px; color: #555; }
    .property-value { margin-top: 3px; word-break: break-word; font-size: 14px; }
    .relationship-link { color: #1976d2; cursor: pointer; text-decoration: underline; }
    .zoom-controls { position: absolute; top: 10px; right: 10px; background-color: white; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 5px; z-index: 10; }
    .zoom-btn { width: 30px; height: 30px; background-color: #fff; border: 1px solid #ddd; margin: 2px; cursor: pointer; border-radius: 3px; font-size: 16px; }
    .zoom-btn:hover { background-color: #f5f5f5; }
    #legend { position: absolute; bottom: 10px; left: 10px; background-color: white; padding: 8px; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 10; font-size: 12px; }
    .legend-item { display: flex; align-items: center; margin: 5px 0; }
    .legend-color { width: 12px; height: 12px; border-radius: 2px; margin-right: 8px; }
    .tab-container { display: flex; margin-bottom: 10px; border-bottom: 1px solid #ddd; }
    .tab { padding: 8px 15px; cursor: pointer; font-size: 14px; background-color: #f8f9fa; border: 1px solid transparent; margin-right: 3px; border-radius: 4px 4px 0 0; }
    .tab.active { background-color: #fff; border-color: #ddd; border-bottom-color: #fff; margin-bottom: -1px; }
    .tab-content { display: none; overflow-y: auto; flex: 1; }
    .tab-content.active { display: block; }
    .filter-group { margin-bottom: 15px; }
    .filter-label { font-size: 13px; font-weight: bold; margin-bottom: 8px; display: block; }
    .filter-options { display: flex; flex-wrap: wrap; gap: 5px; }
    .filter-option { padding: 4px 8px; background-color: #e9ecef; border-radius: 3px; font-size: 12px; cursor: pointer; }
    .filter-option.active { background-color: #1976d2; color: white; }
    .summary { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; }
    .file-input-container { position: relative; display: inline-block; margin-right: 10px; }
    .file-input-label { display: inline-block; padding: 6px 12px; background-color: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .file-input { position: absolute; left: 0; top: 0; opacity: 0; width: 0.1px; height: 0.1px; }
    .file-name { font-size: 14px; color: #ddd; margin-left: 10px; }
    .button { padding: 6px 12px; margin-left: 10px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .no-data { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; color: #6c757d; }
    .no-data-icon { font-size: 48px; margin-bottom: 10px; }
    .loading { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: none; }
    .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #1976d2; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .status-message { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 10px 20px; border-radius: 4px; z-index: 1000; display: none; }
    .debug-info { position: absolute; top: 50px; right: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 5px; font-family: monospace; font-size: 10px; max-width: 300px; z-index: 1000; }
    #clear-filters-btn { display: block; width: 100%; margin-top: 15px; background-color: #f44336; color: white; border: none; border-radius: 4px; padding: 8px; cursor: pointer; font-size: 14px; }
    #clear-filters-btn:hover { background-color: #d32f2f; }
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px;
      border-radius: 4px;
      font-size: 12px;
      max-width: 300px;
      z-index: 1000;
      pointer-events: none;
      transition: all 0.1s ease-out;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .node-tooltip .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
      gap: 12px;
      margin-left: -2px;
    }
    .node-tooltip .title {
      font-weight: bold;
      font-size: 13px;
      line-height: 1.3;
      flex: 1;
      text-align: left;
    }
    .node-tooltip .type-badge {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 3px;
      color: white;
      text-transform: capitalize;
      white-space: nowrap;
      text-align: right;
      flex-shrink: 0;
    }
    .node-tooltip .description {
      font-size: 12px;
      line-height: 1.4;
      opacity: 0.9;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 10px;
    }
    .relationship-detail { background-color: #f5f7fa; padding: 8px; border-radius: 4px; margin-top: 5px; }
    .category-stats { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; }
    .category-count { display: flex; justify-content: space-between; margin-bottom: 5px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Knowledge Graph Explorer</h1>
      <div class="file-controls">
        <div class="file-input-container">
          <label for="file-input" class="file-input-label">Load Knowledge Graph</label>
          <input type="file" id="file-input" class="file-input" accept=".json,.jsonld">
        </div>
        <span class="file-name" id="file-name">No file selected</span>
        <button id="export-btn" class="button">Export Data</button>
      </div>
    </div>
    <div class="main-container">
      <div class="sidebar">
        <div class="tab-container">
          <div class="tab active" data-tab="entities">Entities</div>
          <div class="tab" data-tab="filters">Filters</div>
          <div class="tab" data-tab="stats">Statistics</div>
        </div>

        <div class="tab-content active" id="entities-tab">
          <input type="text" id="search-box" placeholder="Search entities...">
          <div class="entity-list" id="entity-list"></div>
        </div>

        <div class="tab-content" id="filters-tab">
          <button id="clear-filters-btn">Clear All Filters</button>
          <div class="filter-status" id="filter-status"></div>
          <div class="filter-group">
            <span class="filter-label">Entity Types</span>
            <div class="filter-options" id="type-filters"></div>
          </div>
          <div class="filter-group">
            <span class="filter-label">Categories</span>
            <div class="filter-options" id="category-filters"></div>
          </div>
          <div class="filter-group">
            <span class="filter-label">Relationship Types</span>
            <div class="filter-options" id="relationship-filters"></div>
          </div>
        </div>

        <div class="tab-content" id="stats-tab">
          <div class="category-stats" id="stats-container">
            <h3>Graph Statistics</h3>
            <p>Load a knowledge graph to view statistics.</p>
          </div>
        </div>
      </div>

      <div class="main-content">
        <div class="graph-container" id="graph-container">
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-out">-</button>
            <button class="zoom-btn" id="zoom-reset">‚ü≤</button>
          </div>
          <div id="legend"></div>
          <div class="no-data" id="no-data">
            <div class="no-data-icon">üï∏Ô∏è</div>
            <p>Load a knowledge graph JSON file to begin</p>
          </div>
          <div class="loading" id="loading">
            <div class="spinner"></div>
          </div>
          <div class="debug-info" id="debug-info"></div>
        </div>
        <div class="details-panel">
          <div class="details-title">
            <h3 id="details-title">Select an entity to view details</h3>
            <span class="detail-type" id="details-type"></span>
          </div>
          <div id="details-content"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="status-message" id="status-message"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script>
    // Global variables
    let knowledgeGraph = null;
    let entities = {};
    let relationships = [];
    let nodes = [];
    let links = [];
    let simulation = null;
    let svg = null;
    let g = null;
    let zoom = null;
    let link = null;
    let linkText = null;
    let node = null;

    // Filter states
    let activeTypeFilters = new Set();
    let activeCategoryFilters = new Set();
    let activeRelationshipFilters = new Set();
    let searchQuery = '';

    // Colors for entity categories - Digital Article semantic types
    const categoryColors = {
      // Digital Article types
      "da:Notebook": "#009688",
      "da:Cell": "#4CAF50",
      "da:Dataset": "#03A9F4",
      "da:Library": "#607D8B",
      "da:Variable": "#9C27B0",
      "da:Visualization": "#E91E63",
      "da:Finding": "#FF9800",
      "da:Concept": "#673AB7",
      "da:Claim": "#F44336",
      // Standard ontology types
      "dcterms:Text": "#009688",
      "schema:Person": "#4CAF50",
      "schema:Organization": "#2196F3",
      "skos:Concept": "#673AB7",
      "schema:Dataset": "#03A9F4",
      "schema:SoftwareApplication": "#607D8B",
      "default": "#888888"
    };

    // Initialize the application
    document.addEventListener('DOMContentLoaded', initializeApp);

    function initializeApp() {
      setupEventListeners();
      setupTabs();

      // Check for data key in URL parameter
      const urlParams = new URLSearchParams(window.location.search);
      const storageKey = urlParams.get('key');

      if (storageKey) {
        try {
          // Load from localStorage
          const dataStr = localStorage.getItem(storageKey);
          if (dataStr) {
            const data = JSON.parse(dataStr);
            processData(data);
            showStatusMessage("Knowledge graph loaded successfully", "success");

            // Clean up localStorage after loading
            localStorage.removeItem(storageKey);
            document.getElementById('file-name').textContent = "Loaded from Digital Article";
          } else {
            document.getElementById('debug-info').textContent = "Error: Data not found in storage";
            showStatusMessage("Error: Data not found", "error");
          }
        } catch (error) {
          console.error("Error loading data from storage:", error);
          document.getElementById('debug-info').textContent = "Error loading data: " + error.message;
          showStatusMessage("Error loading data: " + error.message, "error");
        }
      } else {
        document.getElementById('debug-info').textContent = "Explorer initialized. Waiting for data...";
      }
    }

    function setupEventListeners() {
      document.getElementById('file-input').addEventListener('change', handleFileSelect);
      document.getElementById('zoom-in').addEventListener('click', zoomIn);
      document.getElementById('zoom-out').addEventListener('click', zoomOut);
      document.getElementById('zoom-reset').addEventListener('click', resetZoom);
      document.getElementById('search-box').addEventListener('input', handleSearch);
      document.getElementById('export-btn').addEventListener('click', exportData);
      document.getElementById('clear-filters-btn').addEventListener('click', clearAllFilters);
    }

    function setupTabs() {
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          tabs.forEach(t => t.classList.remove('active'));
          this.classList.add('active');

          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });

          const tabId = this.getAttribute('data-tab');
          document.getElementById(tabId + '-tab').classList.add('active');
        });
      });
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('file-name').textContent = file.name;
      document.getElementById('loading').style.display = 'block';
      document.getElementById('debug-info').textContent = "Loading file: " + file.name;

      const reader = new FileReader();

      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          processData(data);
          showStatusMessage("Data loaded successfully", "success");
        } catch (error) {
          console.error("Error parsing JSON:", error);
          document.getElementById('debug-info').textContent = "Error: " + error.message;
          showStatusMessage("Error loading data: " + error.message, "error");
        } finally {
          document.getElementById('loading').style.display = 'none';
        }
      };

      reader.onerror = function() {
        console.error("Error reading file");
        document.getElementById('debug-info').textContent = "Error reading file";
        showStatusMessage("Error reading file", "error");
        document.getElementById('loading').style.display = 'none';
      };

      reader.readAsText(file);
    }

    function processData(data) {
      console.log("Processing data:", data);
      knowledgeGraph = data;

      // Clear previous data
      entities = {};
      relationships = [];
      nodes = [];
      links = [];

      // Clear filters
      activeTypeFilters.clear();
      activeCategoryFilters.clear();
      activeRelationshipFilters.clear();
      searchQuery = '';
      document.getElementById('search-box').value = '';

      // Clear visualizations
      clearVisualization();

      // Process Digital Article JSON-LD format
      if (data["@graph"] && data.triples && Array.isArray(data["@graph"]) && Array.isArray(data.triples)) {
        // This is Digital Article export format
        // Process entities from @graph
        data["@graph"].forEach(node => {
          if (node["@id"]) {
            const label = node["rdfs:label"] || node["dcterms:title"] || node["schema:name"] || node["@id"].split(':').pop();
            entities[node["@id"]] = {
              id: node["@id"],
              label: label,
              type: node["@type"] || "Unknown",
              category: node["@type"] || "Unknown",
              properties: { ...node }
            };
          }
        });

        // Process relationships from triples array
        data.triples.forEach((triple, i) => {
          const sourceId = triple.subject;
          const targetId = triple.object;

          // Only create relationship if both entities exist and object is a string (entity ID)
          if (typeof targetId === 'string' && entities[sourceId] && entities[targetId]) {
            const predicate = triple.predicate;
            relationships.push({
              id: `triple-${i}`,
              source: sourceId,
              target: targetId,
              type: predicate,
              label: predicate.split(':').pop() || predicate,
              predicate: predicate,
              properties: { ...triple }
            });
          }
        });
      }
      // Process AbstractCore extractor format
      else if (data.entities && Array.isArray(data.entities)) {
        // Process entities from our extractor format
        data.entities.forEach(entity => {
          if (entity["@id"]) {
            entities[entity["@id"]] = {
              id: entity["@id"],
              label: entity["schema:name"] || entity.name || entity["@id"].split(':').pop(),
              type: entity["@type"] || "Unknown",
              category: entity["@type"] || "Unknown",
              properties: { ...entity }
            };
          }
        });

        // Process relationships from our extractor format
        if (data.relationships && Array.isArray(data.relationships)) {
          data.relationships.forEach((rel, i) => {
            const sourceId = rel.subject && rel.subject["@id"] ? rel.subject["@id"] : null;
            const targetId = rel.object && rel.object["@id"] ? rel.object["@id"] : null;

            if (sourceId && targetId && entities[sourceId] && entities[targetId]) {
              const predicate = rel.predicate || "related";
              relationships.push({
                id: rel["@id"] || `relationship-${i}`,
                source: sourceId,
                target: targetId,
                type: predicate,
                label: predicate.split(':').pop(),
                predicate: predicate, // Store the full predicate for display
                properties: { ...rel }
              });
            }
          });
        }
      }
      // Fallback to original semantic format with @graph
      else if (data["@graph"] && Array.isArray(data["@graph"])) {
        data["@graph"].forEach(node => {
          // Check if this is a relationship node (starts with r: or relationship:)
          const isRelationship = node["@id"] && (
            node["@id"].startsWith("relationship:") ||
            node["@id"].startsWith("r:")
          );

          if (node["@id"] && !isRelationship) {
            entities[node["@id"]] = {
              id: node["@id"],
              label: node["schema:name"] || node["s:name"] || node["skos:definition"] || node["@id"].split(':')[1],
              type: node["@type"] || "Unknown",
              category: node["@type"] || "Unknown",
              properties: { ...node }
            };
          }
        });

        // Process relationships from @graph format
        data["@graph"].forEach(node => {
          // Direct relationships in properties
          Object.entries(node).forEach(([key, value]) => {
            if (typeof value === 'object' && value !== null && value["@id"] && key !== "@id" && key !== "@type") {
              const sourceId = node["@id"];
              const targetId = value["@id"];

              if (entities[sourceId] && entities[targetId]) {
                // Use property name as the relationship label
                const relLabel = key.split(':').pop();
                relationships.push({
                  id: `${sourceId}-${key}-${targetId}`,
                  source: sourceId,
                  target: targetId,
                  type: key,
                  label: relLabel,
                  predicate: relLabel,
                  properties: { relationship: key }
                });
              }
            }
          });

          // Explicit relationship nodes (with r: or relationship: prefix)
          if (node["@id"] && (node["@id"].startsWith("relationship:") || node["@id"].startsWith("r:"))) {
            // Support both s:about/s:object and schema:about/schema:object
            const aboutNode = node["s:about"] || node["schema:about"];
            const objectNode = node["s:object"] || node["schema:object"];

            if (aboutNode && objectNode) {
              const sourceId = aboutNode["@id"];
              const targetId = objectNode["@id"];

              if (entities[sourceId] && entities[targetId]) {
                // Always use s:name or schema:name for label, NOT the ID
                const relName = node["s:name"] || node["schema:name"] || "related";
                relationships.push({
                  id: node["@id"],
                  source: sourceId,
                  target: targetId,
                  type: node["@type"],
                  label: relName,  // Use the name property directly
                  predicate: relName,  // Store for later use
                  properties: { ...node }
                });
              }
            }
          }
        });
      }

      // Convert to arrays for D3
      nodes = Object.values(entities);
      links = relationships.map(r => ({
        ...r,
        source: r.source,
        target: r.target
      }));

      // Debug information
      document.getElementById('debug-info').textContent = `Processed ${nodes.length} entities and ${links.length} relationships`;

      // Update UI
      populateEntityList();
      updateFilters();
      updateStatistics();
      createVisualization();

      // Hide no-data message
      document.getElementById('no-data').style.display = 'none';
    }

    function clearVisualization() {
      const container = document.getElementById('graph-container');
      const svg = container.querySelector('svg');
      if (svg) {
        svg.remove();
      }

      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      // Reset details
      document.getElementById('details-title').textContent = 'Select an entity to view details';
      document.getElementById('details-type').textContent = '';
      document.getElementById('details-content').innerHTML = '';
    }

    function createVisualization() {
      console.log("Creating visualization with entities:", nodes.length);
      console.log("and relationships:", links.length);

      if (nodes.length === 0) {
        document.getElementById('debug-info').textContent = "No entities found to visualize";
        return;
      }

      const container = document.getElementById('graph-container');
      const width = container.offsetWidth;
      const height = container.offsetHeight;

      // Setup SVG
      svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', [0, 0, width, height]);

      // Add zoom
      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on('zoom', event => g.attr('transform', event.transform));

      svg.call(zoom);
      g = svg.append('g');

      // Arrow marker for links
      svg.append('defs').append('marker')
        .attr('id', 'arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 15)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

      // Setup force simulation
      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-400))
        .force('center', d3.forceCenter(width/2, height/2))
        .force('collide', d3.forceCollide().radius(40));

      // Initial positioning in a circle
      const radius = Math.min(width, height) / 3;
      nodes.forEach((d, i) => {
        const angle = (i / nodes.length) * 2 * Math.PI;
        d.x = width/2 + radius * Math.cos(angle);
        d.y = height/2 + radius * Math.sin(angle);
      });

      // Create links
      link = g.append('g')
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('class', d => `link-item link-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .attr('stroke', '#999')
        .attr('stroke-width', 1)
        .attr('marker-end', 'url(#arrow)');

      // Link labels
      linkText = g.append('g')
        .selectAll('text')
        .data(links)
        .enter().append('text')
        .attr('class', d => `link-text-item link-text-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .attr('font-size', '8px')
        .attr('text-anchor', 'middle')
        .attr('dy', -3)
        .text(d => d.label);

      // Create nodes
      const getNodeColor = d => categoryColors[d.category] || categoryColors["default"];

      node = g.append('g')
        .selectAll('g')
        .data(nodes)
        .enter().append('g')
        .attr('class', d => `node-item node-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .call(d3.drag()
          .on('start', dragstart)
          .on('drag', dragging)
          .on('end', dragend))
        .on('click', showDetails)
        .on('mouseover', function(event, d) {
          // Highlight node contour
          d3.select(this).select('circle')
            .attr('stroke', '#e91e63')
            .attr('stroke-width', 2);

          // Highlight connected links
          const nodeId = d.id;
          link.filter(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === nodeId || targetId === nodeId;
          })
            .attr('stroke', '#e91e63')
            .attr('stroke-width', 2);

          linkText.filter(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === nodeId || targetId === nodeId;
          })
            .attr('font-weight', 'bold')
            .attr('fill', '#e91e63');

          // Show tooltip
          const tooltip = document.createElement('div');
          tooltip.className = 'node-tooltip';
          tooltip.id = 'active-tooltip';

          // Create header with title and type badge
          const header = document.createElement('div');
          header.className = 'header';

          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = d.label;

          const typeBadge = document.createElement('div');
          typeBadge.className = 'type-badge';
          typeBadge.textContent = d.type.split(':').pop();
          typeBadge.style.backgroundColor = categoryColors[d.category] || categoryColors["default"];

          header.appendChild(title);
          header.appendChild(typeBadge);

          const description = document.createElement('div');
          description.className = 'description';
          description.textContent = d.properties["dcterms:description"] || d.properties["d:description"] || d.properties["schema:description"] || d.properties["s:description"] || 'No description available';

          tooltip.appendChild(header);
          tooltip.appendChild(description);
          document.body.appendChild(tooltip);

          // Position tooltip near the node
          const nodeBox = this.getBoundingClientRect();
          const tooltipBox = tooltip.getBoundingClientRect();

          const top = nodeBox.top - tooltipBox.height - 10;
          const left = nodeBox.left + (nodeBox.width / 2) - (tooltipBox.width / 2);

          tooltip.style.top = `${Math.max(10, top)}px`;
          tooltip.style.left = `${Math.max(10, Math.min(window.innerWidth - tooltipBox.width - 10, left))}px`;
        })
        .on('mouseout', function(event, d) {
          // Remove highlights
          d3.select(this).select('circle')
            .attr('stroke', null)
            .attr('stroke-width', null);

          link
            .attr('stroke', '#999')
            .attr('stroke-width', 1);

          linkText
            .attr('font-weight', 'normal')
            .attr('fill', '#666');

          // Remove tooltip
          const tooltip = document.getElementById('active-tooltip');
          if (tooltip) {
            tooltip.remove();
          }
        });

      node.append('circle')
        .attr('r', 8)
        .attr('fill', getNodeColor);

      node.append('text')
        .attr('font-size', '10px')
        .attr('x', 10)
        .attr('dy', 4)
        .text(d => d.label);

      // Update positions on each simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        linkText
          .attr('x', d => (d.source.x + d.target.x)/2)
          .attr('y', d => (d.source.y + d.target.y)/2);

        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });

      // Create legend
      createLegend();

      document.getElementById('debug-info').textContent = `Visualization complete: ${nodes.length} entities, ${links.length} relationships`;
    }

    function createLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      const categories = [...new Set(nodes.map(n => n.category))].sort();

      categories.forEach(category => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = categoryColors[category] || categoryColors["default"];

        const label = document.createElement('div');
        label.textContent = category.split(':').pop();

        item.appendChild(colorBox);
        item.appendChild(label);
        legend.appendChild(item);
      });
    }

    function populateEntityList() {
      const container = document.getElementById('entity-list');
      container.innerHTML = '';

      if (nodes.length === 0) {
        const noEntities = document.createElement('div');
        noEntities.textContent = "No entities to display";
        noEntities.style.padding = "10px";
        noEntities.style.color = "#888";
        container.appendChild(noEntities);
        return;
      }

      let filteredNodes = [...nodes];

      // Apply search filter
      if (searchQuery) {
        filteredNodes = filteredNodes.filter(n =>
          n.label.toLowerCase().includes(searchQuery.toLowerCase()) ||
          n.id.toLowerCase().includes(searchQuery.toLowerCase())
        );
      }

      // Apply type filter
      if (activeTypeFilters.size > 0) {
        filteredNodes = filteredNodes.filter(n => activeTypeFilters.has(n.type));
      }

      // Apply category filter
      if (activeCategoryFilters.size > 0) {
        filteredNodes = filteredNodes.filter(n => activeCategoryFilters.has(n.category));
      }

      filteredNodes.forEach(entity => {
        const div = document.createElement('div');
        div.className = 'entity-item';
        div.dataset.id = entity.id;
        div.innerHTML = `
          <strong>${entity.label}</strong>
          <div class="entity-type">${entity.type.split(':').pop()}</div>
        `;
        div.onclick = () => {
          document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
          div.classList.add('selected');
          showDetails(null, entity);
          highlightConnections(entity);
        };
        container.appendChild(div);
      });
    }

    function updateFilters() {
      if (nodes.length === 0) {
        document.getElementById('type-filters').innerHTML = '<div>No data available</div>';
        document.getElementById('category-filters').innerHTML = '<div>No data available</div>';
        document.getElementById('relationship-filters').innerHTML = '<div>No data available</div>';
        return;
      }

      const types = [...new Set(nodes.map(n => n.type))];
      const categories = [...new Set(nodes.map(n => n.category))];
      const relationshipTypes = [...new Set(links.map(l => l.type))];

      // Populate type filters
      const typeFilters = document.getElementById('type-filters');
      typeFilters.innerHTML = '';
      types.forEach(type => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = type.split(':').pop();
        filter.dataset.value = type;
        if (activeTypeFilters.has(type)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeTypeFilters.add(type);
          } else {
            activeTypeFilters.delete(type);
          }
          populateEntityList();
        };
        typeFilters.appendChild(filter);
      });

      // Populate category filters
      const categoryFilters = document.getElementById('category-filters');
      categoryFilters.innerHTML = '';
      categories.forEach(category => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = category.split(':').pop();
        filter.dataset.value = category;
        filter.style.backgroundColor = categoryColors[category] || '#888';
        filter.style.color = 'white';
        if (activeCategoryFilters.has(category)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeCategoryFilters.add(category);
          } else {
            activeCategoryFilters.delete(category);
          }
          populateEntityList();
        };
        categoryFilters.appendChild(filter);
      });

      // Populate relationship filters
      const relationshipFilters = document.getElementById('relationship-filters');
      relationshipFilters.innerHTML = '';
      relationshipTypes.forEach(type => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = type.split(':').pop();
        filter.dataset.value = type;
        if (activeRelationshipFilters.has(type)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeRelationshipFilters.add(type);
          } else {
            activeRelationshipFilters.delete(type);
          }
          highlightRelationshipsByType();
        };
        relationshipFilters.appendChild(filter);
      });
    }

    function highlightRelationshipsByType() {
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');

      if (activeRelationshipFilters.size === 0) {
        return;
      }

      link.filter(l => activeRelationshipFilters.has(l.type))
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);

      linkText.filter(l => activeRelationshipFilters.has(l.type))
        .attr('font-weight', 'bold')
        .attr('fill', '#e91e63');
    }

    function updateStatistics() {
      const container = document.getElementById('stats-container');
      container.innerHTML = '';

      const title = document.createElement('h3');
      title.textContent = 'Graph Statistics';
      container.appendChild(title);

      if (nodes.length === 0 || links.length === 0) {
        const noData = document.createElement('p');
        noData.textContent = 'No data available for statistics';
        container.appendChild(noData);
        return;
      }

      // Entity count by category
      const categoryTitle = document.createElement('h4');
      categoryTitle.textContent = 'Entities by Category';
      container.appendChild(categoryTitle);

      const categoryStats = {};
      nodes.forEach(node => {
        categoryStats[node.category] = (categoryStats[node.category] || 0) + 1;
      });

      Object.entries(categoryStats).forEach(([category, count]) => {
        const div = document.createElement('div');
        div.className = 'category-count';
        div.innerHTML = `
          <span>${category.split(':').pop()}:</span>
          <span>${count}</span>
        `;
        container.appendChild(div);
      });

      // Relationship count by type
      const relationshipTitle = document.createElement('h4');
      relationshipTitle.textContent = 'Relationships by Type';
      container.appendChild(relationshipTitle);

      const relationshipStats = {};
      links.forEach(link => {
        relationshipStats[link.type] = (relationshipStats[link.type] || 0) + 1;
      });

      Object.entries(relationshipStats).forEach(([type, count]) => {
        const div = document.createElement('div');
        div.className = 'category-count';
        div.innerHTML = `
          <span>${type.split(':').pop()}:</span>
          <span>${count}</span>
        `;
        container.appendChild(div);
      });

      // Total counts and extraction metadata
      const summary = document.createElement('div');
      summary.className = 'summary';
      let summaryHTML = `
        <strong>Total Entities:</strong> ${nodes.length}<br>
        <strong>Total Relationships:</strong> ${links.length}
      `;

      // Add extraction metadata if available
      if (knowledgeGraph && knowledgeGraph.extractionMetadata) {
        const metadata = knowledgeGraph.extractionMetadata;
        summaryHTML += `<br><br><strong>Extraction Info:</strong><br>`;

        if (metadata.verificationConfidence !== undefined) {
          summaryHTML += `Verification Confidence: ${(metadata.verificationConfidence * 100).toFixed(1)}%<br>`;
        }

        if (metadata.extractorVersion) {
          summaryHTML += `Extractor: ${metadata.extractorVersion}<br>`;
        }

        // Handle deduplication summary (can be string or object)
        if (metadata.deduplicationSummary) {
          if (typeof metadata.deduplicationSummary === 'object') {
            const dedup = metadata.deduplicationSummary;
            summaryHTML += `Deduplication: ${dedup.merged} merged, ${dedup.created} created<br>`;
          } else {
            summaryHTML += `Deduplication: ${metadata.deduplicationSummary}<br>`;
          }
        }
      }

      // Add source information
      if (knowledgeGraph && (knowledgeGraph["dcterms:source"] || knowledgeGraph["dcterms:created"])) {
        summaryHTML += `<br><strong>Source:</strong><br>`;
        if (knowledgeGraph["dcterms:source"]) {
          summaryHTML += `File: ${knowledgeGraph["dcterms:source"]}<br>`;
        }
        if (knowledgeGraph["dcterms:created"]) {
          const date = new Date(knowledgeGraph["dcterms:created"]);
          summaryHTML += `Created: ${date.toLocaleString()}<br>`;
        }
      }

      summary.innerHTML = summaryHTML;
      container.appendChild(summary);
    }

    function handleSearch(event) {
      searchQuery = event.target.value;
      populateEntityList();
    }

    function clearAllFilters() {
      activeTypeFilters.clear();
      activeCategoryFilters.clear();
      activeRelationshipFilters.clear();
      searchQuery = '';
      document.getElementById('search-box').value = '';

      document.querySelectorAll('.filter-option').forEach(el => {
        el.classList.remove('active');
      });

      populateEntityList();

      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');

      showStatusMessage("All filters cleared", "info");
    }

    function showDetails(event, d) {
      const detailsTitle = document.getElementById('details-title');
      const detailsType = document.getElementById('details-type');
      const detailsContent = document.getElementById('details-content');

      detailsTitle.textContent = d.label;
      detailsType.textContent = d.type.split(':').pop();
      detailsContent.innerHTML = '';

      // Show description if available (support both abbreviated and full prefixes)
      const description = d.properties["dcterms:description"] || d.properties["d:description"] ||
                          d.properties["schema:description"] || d.properties["s:description"];
      if (description) {
        const summary = document.createElement('div');
        summary.className = 'summary';
        summary.textContent = description;
        detailsContent.appendChild(summary);
      }

      // Show the entity ID
      const idProperty = document.createElement('div');
      idProperty.className = 'property';
      idProperty.innerHTML = `
        <div class="property-name">ID:</div>
        <div class="property-value">${d.id}</div>
      `;
      detailsContent.appendChild(idProperty);

      // Show confidence if available
      if (d.properties.confidence !== undefined) {
        const confidenceProperty = document.createElement('div');
        confidenceProperty.className = 'property';
        confidenceProperty.innerHTML = `
          <div class="property-name">Confidence:</div>
          <div class="property-value">${(d.properties.confidence * 100).toFixed(1)}%</div>
        `;
        detailsContent.appendChild(confidenceProperty);
      }

      // Show semantic type with proper formatting
      if (d.type !== d.properties["@type"]) {
        const typeProperty = document.createElement('div');
        typeProperty.className = 'property';
        typeProperty.innerHTML = `
          <div class="property-name">Semantic Type:</div>
          <div class="property-value">${d.properties["@type"] || d.type}</div>
        `;
        detailsContent.appendChild(typeProperty);
      }

      // Show aliases if available (support both abbreviated and full prefixes)
      const altLabel = d.properties["skos:altLabel"] || d.properties["sk:altLabel"];
      if (altLabel) {
        const aliasProperty = document.createElement('div');
        aliasProperty.className = 'property';
        const aliases = Array.isArray(altLabel)
          ? altLabel.join(', ')
          : altLabel;
        aliasProperty.innerHTML = `
          <div class="property-name">Aliases:</div>
          <div class="property-value">${aliases}</div>
        `;
        detailsContent.appendChild(aliasProperty);
      }

      // Show connected relationships
      const relatedTitle = document.createElement('h4');
      relatedTitle.textContent = 'Connected Relationships';
      detailsContent.appendChild(relatedTitle);

      const connectedLinks = links.filter(l =>
        (typeof l.source === 'object' ? l.source.id === d.id : l.source === d.id) ||
        (typeof l.target === 'object' ? l.target.id === d.id : l.target === d.id)
      );

      if (connectedLinks.length > 0) {
        connectedLinks.forEach(link => {
          const relationshipDiv = document.createElement('div');
          relationshipDiv.className = 'relationship-detail';

          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;

          const sourceName = entities[sourceId].label;
          const targetName = entities[targetId].label;

          // Use the predicate/label from the link object (already extracted from s:name)
          const predicate = link.predicate || link.label || 'related';

          relationshipDiv.innerHTML = `
            <strong>${sourceName}</strong> ‚Üí
            <em>${predicate}</em> ‚Üí
            <strong>${targetName}</strong>
          `;

          // Support both abbreviated and full prefixes for description
          const relDescription = link.properties && (link.properties["dcterms:description"] || link.properties["d:description"] ||
                                                      link.properties["schema:description"] || link.properties["s:description"]);
          if (relDescription) {
            const descDiv = document.createElement('div');
            descDiv.style.fontSize = '12px';
            descDiv.style.marginTop = '5px';
            descDiv.textContent = relDescription;
            relationshipDiv.appendChild(descDiv);
          }

          detailsContent.appendChild(relationshipDiv);
        });
      } else {
        const noRelationships = document.createElement('div');
        noRelationships.className = 'property-value';
        noRelationships.textContent = 'No connected relationships found.';
        detailsContent.appendChild(noRelationships);
      }
    }

    function highlightConnections(d) {
      node.selectAll('circle').attr('r', 8).attr('stroke', null);
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');

      const nodeId = d.id;
      const connectedLinks = links.filter(l =>
        (typeof l.source === 'object' ? l.source.id === nodeId : l.source === nodeId) ||
        (typeof l.target === 'object' ? l.target.id === nodeId : l.target === nodeId)
      );

      const connectedNodes = new Set([nodeId]);
      connectedLinks.forEach(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        connectedNodes.add(sourceId);
        connectedNodes.add(targetId);
      });

      // Highlight the node
      node.filter(n => n.id === nodeId)
        .select('circle')
        .attr('r', 12)
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);

      // Highlight connected nodes
      node.filter(n => connectedNodes.has(n.id) && n.id !== nodeId)
        .select('circle')
        .attr('r', 10)
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 1);

      // Highlight links
      link.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === nodeId || targetId === nodeId;
      })
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);

      linkText.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === nodeId || targetId === nodeId;
      })
        .attr('font-weight', 'bold')
        .attr('fill', '#e91e63');
    }

    // Zoom functions
    function zoomIn() {
      if (svg) {
        svg.transition().call(zoom.scaleBy, 1.3);
      }
    }

    function zoomOut() {
      if (svg) {
        svg.transition().call(zoom.scaleBy, 0.7);
      }
    }

    function resetZoom() {
      if (svg) {
        svg.transition().call(zoom.transform, d3.zoomIdentity);
      }
    }

    // Drag functions
    function dragstart(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragging(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragend(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function exportData() {
      if (!knowledgeGraph) {
        showStatusMessage("No data to export", "error");
        return;
      }

      const dataStr = JSON.stringify(knowledgeGraph, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

      const exportFileName = 'knowledge-graph-export.json';

      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileName);
      linkElement.click();
    }

    function showStatusMessage(message, type = 'info') {
      const statusElement = document.getElementById('status-message');
      statusElement.textContent = message;
      statusElement.style.backgroundColor = type === 'error' ? '#f44336' : '#4CAF50';
      statusElement.style.display = 'block';

      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 3000);
    }
  </script>
</body>
</html>