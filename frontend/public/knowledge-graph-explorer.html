<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Knowledge Graph Explorer</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; background-color: #f7f9fc; color: #333; }
    .container { display: flex; height: 100vh; flex-direction: column; }
    .header { background-color: #2c3e50; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
    .header h1 { margin: 0; font-size: 20px; }
    .file-controls { display: flex; align-items: center; }
    .main-container { display: flex; flex: 1; overflow: hidden; }
    .sidebar { width: 280px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 15px; overflow-y: auto; display: flex; flex-direction: column; }
    .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .graph-container { flex: 1; background-color: #fff; margin: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); position: relative; overflow: hidden; }
    .details-panel { height: 230px; background-color: #fff; margin: 0 10px 10px 10px; padding: 15px; box-shadow: 0 0 10px rgba(0,0,0,0.1); overflow-y: auto; }
    .entity-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
    .entity-item { padding: 10px; margin-bottom: 5px; background-color: #f8f9fa; border-left: 3px solid #6c757d; cursor: pointer; border-radius: 3px; transition: all 0.2s; }
    .entity-item:hover { background-color: #e9ecef; transform: translateX(2px); }
    .entity-item.selected { background-color: #e3f2fd; border-left-color: #1976d2; }
    .entity-type { font-size: 11px; color: #666; margin-top: 3px; }
    #search-box { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; box-sizing: border-box; }
    h3 { color: #2c3e50; margin-top: 10px; margin-bottom: 10px; font-size: 16px; }
    .details-title { display: flex; justify-content: space-between; align-items: center; }
    .details-title h3 { margin: 0; }
    .detail-type { font-size: 12px; color: #666; font-style: italic; }
    .property { margin-bottom: 8px; }
    .property-name { font-weight: bold; font-size: 13px; color: #555; }
    .property-value { margin-top: 3px; word-break: break-word; font-size: 14px; }
    .relationship-link { color: #1976d2; cursor: pointer; text-decoration: underline; }
    .zoom-controls { position: absolute; top: 10px; right: 10px; background-color: white; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1); padding: 5px; z-index: 10; }
    .zoom-btn { width: 30px; height: 30px; background-color: #fff; border: 1px solid #ddd; margin: 2px; cursor: pointer; border-radius: 3px; font-size: 16px; }
    .zoom-btn:hover { background-color: #f5f5f5; }
    #legend { position: absolute; bottom: 10px; left: 10px; background-color: white; padding: 8px; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 10; font-size: 12px; }
    .legend-item { display: flex; align-items: center; margin: 5px 0; }
    .legend-color { width: 12px; height: 12px; border-radius: 2px; margin-right: 8px; }
    .tab-container { display: flex; margin-bottom: 10px; border-bottom: 1px solid #ddd; }
    .tab { padding: 8px 15px; cursor: pointer; font-size: 14px; background-color: #f8f9fa; border: 1px solid transparent; margin-right: 3px; border-radius: 4px 4px 0 0; }
    .tab.active { background-color: #fff; border-color: #ddd; border-bottom-color: #fff; margin-bottom: -1px; }
    .tab-content { display: none; overflow-y: auto; flex: 1; }
    .tab-content.active { display: block; }
    .filter-group { margin-bottom: 15px; }
    .filter-label { font-size: 13px; font-weight: bold; margin-bottom: 8px; display: block; }
    .filter-options { display: flex; flex-wrap: wrap; gap: 5px; }
    .filter-option { padding: 4px 8px; background-color: #e9ecef; border-radius: 3px; font-size: 12px; cursor: pointer; }
    .filter-option.active { background-color: #1976d2; color: white; }
    .summary { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; }
    .file-input-container { position: relative; display: inline-block; margin-right: 10px; }
    .file-input-label { display: inline-block; padding: 6px 12px; background-color: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .file-input { position: absolute; left: 0; top: 0; opacity: 0; width: 0.1px; height: 0.1px; }
    .file-name { font-size: 14px; color: #ddd; margin-left: 10px; }
    .button { padding: 6px 12px; margin-left: 10px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
    .no-data { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; color: #6c757d; }
    .no-data-icon { font-size: 48px; margin-bottom: 10px; }
    .loading { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: none; }
    .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #1976d2; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .status-message { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 10px 20px; border-radius: 4px; z-index: 1000; display: none; }
    .debug-info { position: absolute; top: 50px; right: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 5px; font-family: monospace; font-size: 10px; max-width: 300px; z-index: 1000; }
    #clear-filters-btn { display: block; width: 100%; margin-top: 15px; background-color: #f44336; color: white; border: none; border-radius: 4px; padding: 8px; cursor: pointer; font-size: 14px; }
    #clear-filters-btn:hover { background-color: #d32f2f; }
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px;
      border-radius: 4px;
      font-size: 12px;
      max-width: 300px;
      z-index: 1000;
      pointer-events: none;
      transition: all 0.1s ease-out;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .node-tooltip .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
      gap: 12px;
      margin-left: -2px;
    }
    .node-tooltip .title {
      font-weight: bold;
      font-size: 13px;
      line-height: 1.3;
      flex: 1;
      text-align: left;
    }
    .node-tooltip .type-badge {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 3px;
      color: white;
      text-transform: capitalize;
      white-space: nowrap;
      text-align: right;
      flex-shrink: 0;
    }
    .node-tooltip .description {
      font-size: 12px;
      line-height: 1.4;
      opacity: 0.9;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 10px;
    }
    .relationship-detail { background-color: #f5f7fa; padding: 8px; border-radius: 4px; margin-top: 5px; }
    .category-stats { background-color: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; }
    .category-count { display: flex; justify-content: space-between; margin-bottom: 5px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Knowledge Graph Explorer</h1>
      <div class="file-controls">
        <div class="file-input-container">
          <label for="file-input" class="file-input-label">Load Knowledge Graph</label>
          <input type="file" id="file-input" class="file-input" accept=".json,.jsonld">
        </div>
        <span class="file-name" id="file-name">No file selected</span>
        <button id="export-btn" class="button">Export Data</button>
      </div>
    </div>
    <div class="main-container">
      <div class="sidebar">
        <div class="tab-container">
          <div class="tab active" data-tab="entities">Entities</div>
          <div class="tab" data-tab="filters">Filters</div>
          <div class="tab" data-tab="stats">Statistics</div>
        </div>

        <div class="tab-content active" id="entities-tab">
          <input type="text" id="search-box" placeholder="Search entities...">
          <div class="entity-list" id="entity-list"></div>
        </div>

        <div class="tab-content" id="filters-tab">
          <button id="clear-filters-btn">Clear All Filters</button>
          <div class="filter-status" id="filter-status"></div>
          <div class="filter-group">
            <span class="filter-label">Entity Types</span>
            <div class="filter-options" id="type-filters"></div>
          </div>
          <div class="filter-group">
            <span class="filter-label">Categories</span>
            <div class="filter-options" id="category-filters"></div>
          </div>
          <div class="filter-group">
            <span class="filter-label">Relationship Types</span>
            <div class="filter-options" id="relationship-filters"></div>
          </div>
        </div>

        <div class="tab-content" id="stats-tab">
          <div class="category-stats" id="stats-container">
            <h3>Graph Statistics</h3>
            <p>Load a knowledge graph to view statistics.</p>
          </div>
        </div>
      </div>

      <div class="main-content">
        <div class="graph-container" id="graph-container">
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-out">-</button>
            <button class="zoom-btn" id="zoom-reset">‚ü≤</button>
          </div>
          <div id="legend"></div>
          <div class="no-data" id="no-data">
            <div class="no-data-icon">üï∏Ô∏è</div>
            <p>Load a knowledge graph JSON file to begin</p>
          </div>
          <div class="loading" id="loading">
            <div class="spinner"></div>
          </div>
          <div class="debug-info" id="debug-info"></div>
        </div>
        <div class="details-panel">
          <div class="details-title">
            <h3 id="details-title">Select an entity to view details</h3>
            <span class="detail-type" id="details-type"></span>
          </div>
          <div id="details-content"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="status-message" id="status-message"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script>
    // Global variables
    let knowledgeGraph = null;
    let entities = {};
    let relationships = [];
    let nodes = [];
    let links = [];
    let simulation = null;
    let svg = null;
    let g = null;
    let zoom = null;
    let link = null;
    let linkText = null;
    let node = null;

    // Filter states
    let activeTypeFilters = new Set();
    let activeCategoryFilters = new Set();
    let activeRelationshipFilters = new Set();
    let searchQuery = '';

    // Colors for entity categories - Digital Article semantic types
    const categoryColors = {
      // Digital Article types
      "da:Notebook": "#009688",
      "da:Cell": "#78909C",  // Lighter gray for steps
      "da:Dataset": "#2196F3",  // Blue for data assets
      "da:Transformation": "#FF6F00",  // Orange for transformations/methods
      "da:Refined_asset": "#7B1FA2",  // Purple for refined/intermediate data
      "da:Library": "#607D8B",
      "da:Variable": "#9C27B0",
      "da:Visualization": "#E91E63",
      "da:Finding": "#4CAF50",  // Green for outcomes/findings
      "da:Concept": "#673AB7",
      "da:Claim": "#F44336",
      // Standard ontology types
      "dcterms:Text": "#009688",
      "schema:Person": "#4CAF50",
      "schema:Organization": "#2196F3",
      "skos:Concept": "#673AB7",
      "schema:Dataset": "#2196F3",
      "dcat:Dataset": "#2196F3",  // Same as Dataset
      "schema:SoftwareApplication": "#607D8B",
      "default": "#888888"
    };

    // Initialize the application
    document.addEventListener('DOMContentLoaded', initializeApp);

    function initializeApp() {
      setupEventListeners();
      setupTabs();

      // Check for data key in URL parameter
      const urlParams = new URLSearchParams(window.location.search);
      const storageKey = urlParams.get('key');

      if (storageKey) {
        try {
          // Load from localStorage
          const dataStr = localStorage.getItem(storageKey);
          if (dataStr) {
            const data = JSON.parse(dataStr);
            processData(data);
            showStatusMessage("Knowledge graph loaded successfully", "success");

            // Clean up localStorage after loading
            localStorage.removeItem(storageKey);
            document.getElementById('file-name').textContent = "Loaded from Digital Article";
          } else {
            document.getElementById('debug-info').textContent = "Error: Data not found in storage";
            showStatusMessage("Error: Data not found", "error");
          }
        } catch (error) {
          console.error("Error loading data from storage:", error);
          document.getElementById('debug-info').textContent = "Error loading data: " + error.message;
          showStatusMessage("Error loading data: " + error.message, "error");
        }
      } else {
        document.getElementById('debug-info').textContent = "Explorer initialized. Waiting for data...";
      }
    }

    function setupEventListeners() {
      document.getElementById('file-input').addEventListener('change', handleFileSelect);
      document.getElementById('zoom-in').addEventListener('click', zoomIn);
      document.getElementById('zoom-out').addEventListener('click', zoomOut);
      document.getElementById('zoom-reset').addEventListener('click', resetZoom);
      document.getElementById('search-box').addEventListener('input', handleSearch);
      document.getElementById('export-btn').addEventListener('click', exportData);
      document.getElementById('clear-filters-btn').addEventListener('click', clearAllFilters);
    }

    function setupTabs() {
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          tabs.forEach(t => t.classList.remove('active'));
          this.classList.add('active');

          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });

          const tabId = this.getAttribute('data-tab');
          document.getElementById(tabId + '-tab').classList.add('active');
        });
      });
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('file-name').textContent = file.name;
      document.getElementById('loading').style.display = 'block';
      document.getElementById('debug-info').textContent = "Loading file: " + file.name;

      const reader = new FileReader();

      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          processData(data);
          showStatusMessage("Data loaded successfully", "success");
        } catch (error) {
          console.error("Error parsing JSON:", error);
          document.getElementById('debug-info').textContent = "Error: " + error.message;
          showStatusMessage("Error loading data: " + error.message, "error");
        } finally {
          document.getElementById('loading').style.display = 'none';
        }
      };

      reader.onerror = function() {
        console.error("Error reading file");
        document.getElementById('debug-info').textContent = "Error reading file";
        showStatusMessage("Error reading file", "error");
        document.getElementById('loading').style.display = 'none';
      };

      reader.readAsText(file);
    }

    function processData(data) {
      console.log("Processing data:", data);
      knowledgeGraph = data;

      // Clear previous data
      entities = {};
      relationships = [];
      nodes = [];
      links = [];

      // Clear filters
      activeTypeFilters.clear();
      activeCategoryFilters.clear();
      activeRelationshipFilters.clear();
      searchQuery = '';
      document.getElementById('search-box').value = '';

      // Clear visualizations
      clearVisualization();

      // Process Digital Article JSON-LD format
      if (data["@graph"] && data.triples && Array.isArray(data["@graph"]) && Array.isArray(data.triples)) {
        // This is Digital Article export format
        // Process entities from @graph
        data["@graph"].forEach(node => {
          if (node["@id"]) {
            const label = node["rdfs:label"] || node["dcterms:title"] || node["schema:name"] || node["@id"].split(':').pop();
            entities[node["@id"]] = {
              id: node["@id"],
              label: label,
              type: node["@type"] || "Unknown",
              category: node["@type"] || "Unknown",
              properties: { ...node }
            };
          }
        });

        // Process relationships from triples array
        data.triples.forEach((triple, i) => {
          const sourceId = triple.subject;
          const targetId = triple.object;

          // Only create relationship if both entities exist and object is a string (entity ID)
          if (typeof targetId === 'string' && entities[sourceId] && entities[targetId]) {
            const predicate = triple.predicate;
            relationships.push({
              id: `triple-${i}`,
              source: sourceId,
              target: targetId,
              type: predicate,
              label: predicate.split(':').pop() || predicate,
              predicate: predicate,
              properties: { ...triple }
            });
          }
        });
      }
      // Process AbstractCore extractor format
      else if (data.entities && Array.isArray(data.entities)) {
        // Process entities from our extractor format
        data.entities.forEach(entity => {
          if (entity["@id"]) {
            entities[entity["@id"]] = {
              id: entity["@id"],
              label: entity["schema:name"] || entity.name || entity["@id"].split(':').pop(),
              type: entity["@type"] || "Unknown",
              category: entity["@type"] || "Unknown",
              properties: { ...entity }
            };
          }
        });

        // Process relationships from our extractor format
        if (data.relationships && Array.isArray(data.relationships)) {
          data.relationships.forEach((rel, i) => {
            const sourceId = rel.subject && rel.subject["@id"] ? rel.subject["@id"] : null;
            const targetId = rel.object && rel.object["@id"] ? rel.object["@id"] : null;

            if (sourceId && targetId && entities[sourceId] && entities[targetId]) {
              const predicate = rel.predicate || "related";
              relationships.push({
                id: rel["@id"] || `relationship-${i}`,
                source: sourceId,
                target: targetId,
                type: predicate,
                label: predicate.split(':').pop(),
                predicate: predicate, // Store the full predicate for display
                properties: { ...rel }
              });
            }
          });
        }
      }
      // Fallback to original semantic format with @graph
      else if (data["@graph"] && Array.isArray(data["@graph"])) {
        data["@graph"].forEach(node => {
          // Check if this is a relationship node (starts with r: or relationship:)
          const isRelationship = node["@id"] && (
            node["@id"].startsWith("relationship:") ||
            node["@id"].startsWith("r:")
          );

          if (node["@id"] && !isRelationship) {
            entities[node["@id"]] = {
              id: node["@id"],
              label: node["schema:name"] || node["s:name"] || node["skos:definition"] || node["@id"].split(':')[1],
              type: node["@type"] || "Unknown",
              category: node["@type"] || "Unknown",
              properties: { ...node }
            };
          }
        });

        // Process relationships from @graph format
        data["@graph"].forEach(node => {
          // Direct relationships in properties
          Object.entries(node).forEach(([key, value]) => {
            if (typeof value === 'object' && value !== null && value["@id"] && key !== "@id" && key !== "@type") {
              const sourceId = node["@id"];
              const targetId = value["@id"];

              if (entities[sourceId] && entities[targetId]) {
                // Use property name as the relationship label
                const relLabel = key.split(':').pop();
                relationships.push({
                  id: `${sourceId}-${key}-${targetId}`,
                  source: sourceId,
                  target: targetId,
                  type: key,
                  label: relLabel,
                  predicate: relLabel,
                  properties: { relationship: key }
                });
              }
            }
          });

          // Explicit relationship nodes (with r: or relationship: prefix)
          if (node["@id"] && (node["@id"].startsWith("relationship:") || node["@id"].startsWith("r:"))) {
            // Support both s:about/s:object and schema:about/schema:object
            const aboutNode = node["s:about"] || node["schema:about"];
            const objectNode = node["s:object"] || node["schema:object"];

            if (aboutNode && objectNode) {
              const sourceId = aboutNode["@id"];
              const targetId = objectNode["@id"];

              if (entities[sourceId] && entities[targetId]) {
                // Always use s:name or schema:name for label, NOT the ID
                const relName = node["s:name"] || node["schema:name"] || "related";
                relationships.push({
                  id: node["@id"],
                  source: sourceId,
                  target: targetId,
                  type: node["@type"],
                  label: relName,  // Use the name property directly
                  predicate: relName,  // Store for later use
                  properties: { ...node }
                });
              }
            }
          }
        });
      }

      // Convert to arrays for D3
      nodes = Object.values(entities);
      links = relationships.map(r => ({
        ...r,
        source: r.source,
        target: r.target
      }));

      // Debug information
      document.getElementById('debug-info').textContent = `Processed ${nodes.length} entities and ${links.length} relationships`;

      // Update UI
      populateEntityList();
      updateFilters();
      updateStatistics();
      createVisualization();

      // Hide no-data message
      document.getElementById('no-data').style.display = 'none';
    }

    function clearVisualization() {
      const container = document.getElementById('graph-container');
      const svg = container.querySelector('svg');
      if (svg) {
        svg.remove();
      }

      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      // Reset details
      document.getElementById('details-title').textContent = 'Select an entity to view details';
      document.getElementById('details-type').textContent = '';
      document.getElementById('details-content').innerHTML = '';
    }

    function createVisualization() {
      console.log("Creating visualization with entities:", nodes.length);
      console.log("and relationships:", links.length);

      if (nodes.length === 0) {
        document.getElementById('debug-info').textContent = "No entities found to visualize";
        return;
      }

      // Detect graph type from metadata
      const isProfileGraph = knowledgeGraph.metadata?.graph_type === 'profile';
      const layoutHint = knowledgeGraph.metadata?.layout_hint;

      console.log("Graph type:", isProfileGraph ? "Profile (hierarchical)" : "Analysis (force-directed)");

      const container = document.getElementById('graph-container');
      const width = container.offsetWidth;
      const height = container.offsetHeight;

      // Use hierarchical layout for profile graphs, force-directed for others
      if (isProfileGraph && layoutHint === 'hierarchical') {
        createHierarchicalVisualization(container, width, height);
      } else {
        createForceDirectedVisualization(container, width, height);
      }
    }

    function createHierarchicalVisualization(container, width, height) {
      console.log("Creating hierarchical tree visualization for profile");

      // Clear previous
      const existingSvg = container.querySelector('svg');
      if (existingSvg) existingSvg.remove();

      // Build hierarchy from flat graph structure
      const hierarchy = buildHierarchyFromGraph();

      // Setup SVG
      svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', [0, 0, width, height]);

      // Add zoom
      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on('zoom', event => g.attr('transform', event.transform));

      svg.call(zoom);
      g = svg.append('g');

      // Create tree layout (left-to-right orientation)
      const treeLayout = d3.tree()
        .size([height - 100, width - 400])
        .separation((a, b) => a.parent == b.parent ? 1 : 1.5);

      // Convert to d3 hierarchy and apply layout
      const root = d3.hierarchy(hierarchy);
      treeLayout(root);

      // Draw links (edges between nodes)
      const link = g.append('g')
        .attr('fill', 'none')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.4)
        .attr('stroke-width', 2)
        .selectAll('path')
        .data(root.links())
        .enter().append('path')
        .attr('d', d3.linkHorizontal()
          .x(d => d.y + 200)
          .y(d => d.x + 50));

      // Draw nodes
      const node = g.append('g')
        .selectAll('g')
        .data(root.descendants())
        .enter().append('g')
        .attr('transform', d => `translate(${d.y + 200},${d.x + 50})`)
        .on('click', function(event, d) {
          if (d.data.entity) {
            showDetails(event, d.data.entity);
          }
        });

      // Color by level
      const getLevelColor = d => {
        if (d.depth === 0) return '#1a237e'; // User (darkest blue)
        if (d.depth === 1) return '#303f9f'; // Domain (dark blue)
        if (d.depth === 2) return '#5c6bc0'; // Category (medium blue)
        return '#7986cb';  // Skill (light blue)
      };

      // Size by proficiency
      const getProficiencySize = d => {
        if (!d.data.entity || !d.data.entity.properties) return 8;
        const proficiency = d.data.entity.properties['da:proficiency'];
        if (proficiency === 'Expert') return 16;
        if (proficiency === 'Advanced') return 12;
        if (proficiency === 'Intermediate') return 8;
        return 5; // Basic
      };

      // Node circles
      node.append('circle')
        .attr('r', getProficiencySize)
        .attr('fill', getLevelColor)
        .attr('stroke', '#fff')
        .attr('stroke-width', 2);

      // Node labels
      node.append('text')
        .attr('dy', '0.31em')
        .attr('x', d => d.children ? -12 : 12)
        .attr('text-anchor', d => d.children ? 'end' : 'start')
        .text(d => d.data.name)
        .style('font-size', d => d.depth === 0 ? '14px' : d.depth === 1 ? '12px' : '10px')
        .style('font-weight', d => d.depth <= 1 ? 'bold' : 'normal')
        .style('fill', '#333');

      // Create hierarchical legend
      createHierarchicalLegend();

      document.getElementById('debug-info').textContent = `Hierarchical profile: ${nodes.length} entities`;
    }

    function buildHierarchyFromGraph() {
      // Find the user/author node (root)
      const userNode = nodes.find(n => n.type === 'schema:Person');

      if (!userNode) {
        console.error("No user/author node found");
        return {name: "Unknown User", children: []};
      }

      // Find domains (linked from user or have type da:Domain)
      const domainNodes = nodes.filter(n => n.type === 'da:Domain');

      // Build hierarchical structure
      const hierarchy = {
        name: userNode.label,
        entity: userNode,
        children: []
      };

      domainNodes.forEach(domain => {
        const domainObj = {
          name: domain.label,
          entity: domain,
          children: []
        };

        // Find categories under this domain
        const categoryLinks = links.filter(l =>
          l.predicate === 'da:contains' &&
          l.source === domain.id
        );

        categoryLinks.forEach(catLink => {
          const category = nodes.find(n => n.id === catLink.target);
          if (category) {
            const categoryObj = {
              name: category.label,
              entity: category,
              children: []
            };

            // Find skills under this category
            const skillLinks = links.filter(l =>
              l.predicate === 'da:contains' &&
              l.source === category.id
            );

            skillLinks.forEach(skillLink => {
              const skill = nodes.find(n => n.id === skillLink.target);
              if (skill) {
                categoryObj.children.push({
                  name: skill.label,
                  entity: skill
                });
              }
            });

            domainObj.children.push(categoryObj);
          }
        });

        hierarchy.children.push(domainObj);
      });

      return hierarchy;
    }

    function createHierarchicalLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      // Title
      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.style.marginBottom = '8px';
      title.style.fontSize = '13px';
      title.textContent = 'Profile Graph Legend';
      legend.appendChild(title);

      // Hierarchy levels
      const levelsTitle = document.createElement('div');
      levelsTitle.style.fontWeight = 'bold';
      levelsTitle.style.marginTop = '10px';
      levelsTitle.style.marginBottom = '5px';
      levelsTitle.style.fontSize = '11px';
      levelsTitle.textContent = 'Hierarchy Levels:';
      legend.appendChild(levelsTitle);

      const levels = [
        { color: '#1a237e', label: 'User' },
        { color: '#303f9f', label: 'Domain (Field)' },
        { color: '#5c6bc0', label: 'Category (Specialization)' },
        { color: '#7986cb', label: 'Skill (Competency)' }
      ];

      levels.forEach(level => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.style.fontSize = '11px';

        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = level.color;

        const label = document.createElement('div');
        label.textContent = level.label;

        item.appendChild(colorBox);
        item.appendChild(label);
        legend.appendChild(item);
      });

      // Proficiency levels
      const profTitle = document.createElement('div');
      profTitle.style.fontWeight = 'bold';
      profTitle.style.marginTop = '10px';
      profTitle.style.marginBottom = '5px';
      profTitle.style.fontSize = '11px';
      profTitle.textContent = 'Proficiency:';
      legend.appendChild(profTitle);

      const proficiencies = [
        { size: 16, label: 'Expert' },
        { size: 12, label: 'Advanced' },
        { size: 8, label: 'Intermediate' },
        { size: 5, label: 'Basic' }
      ];

      proficiencies.forEach(prof => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.style.fontSize = '11px';

        const circle = document.createElement('div');
        circle.style.width = `${prof.size}px`;
        circle.style.height = `${prof.size}px`;
        circle.style.borderRadius = '50%';
        circle.style.backgroundColor = '#7986cb';
        circle.style.marginRight = '8px';
        circle.style.flexShrink = '0';

        const label = document.createElement('div');
        label.textContent = prof.label;

        item.appendChild(circle);
        item.appendChild(label);
        legend.appendChild(item);
      });
    }

    function createForceDirectedVisualization(container, width, height) {
      console.log("Creating force-directed visualization");

      // Clear previous
      const existingSvg = container.querySelector('svg');
      if (existingSvg) existingSvg.remove();

      // Setup SVG
      svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', [0, 0, width, height]);

      // Add zoom
      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on('zoom', event => g.attr('transform', event.transform));

      svg.call(zoom);
      g = svg.append('g');

      // Create colored arrow markers for each relationship type
      const arrowColors = {
        'prov:used': '#2196F3',
        'prov:wasGeneratedBy': '#7B1FA2',
        'prov:wasDerivedFrom': '#4CAF50',
        'da:performsTransformation': '#FF6F00',
        'da:produces': '#4CAF50',
        'schema:nextItem': '#FF0000',  // Bright RED for workflow sequence
        'dcterms:hasPart': '#9E9E9E',
        'default': '#BDBDBD'
      };

      const defs = svg.append('defs');

      Object.entries(arrowColors).forEach(([key, color]) => {
        const markerId = `arrow-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
        defs.append('marker')
          .attr('id', markerId)
          .attr('viewBox', '0 -5 10 10')
          .attr('refX', 20)
          .attr('markerWidth', 8)
          .attr('markerHeight', 8)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M0,-5L10,0L0,5')
          .attr('fill', color);
      });

      // Separate step nodes from other nodes for timeline layout
      const stepNodes = nodes.filter(n => n.type === 'da:Cell')
        .sort((a, b) => {
          const orderA = a.properties['da:executionOrder'] || 0;
          const orderB = b.properties['da:executionOrder'] || 0;
          return orderA - orderB;
        });
      const otherNodes = nodes.filter(n => n.type !== 'da:Cell');

      // Position step nodes in horizontal zigzag timeline (alternating up/down)
      const timelineY = height / 2;  // Center line
      const zigzagOffset = 150;  // Vertical offset for alternating positions
      const stepStartX = 150;
      const stepEndX = width - 150;
      const stepSpacingX = stepNodes.length > 1
        ? (stepEndX - stepStartX) / (stepNodes.length - 1)
        : 0;

      stepNodes.forEach((step, i) => {
        step.fx = stepStartX + i * stepSpacingX;  // Horizontal progression
        // Alternate: even indices up, odd indices down
        step.fy = i % 2 === 0 ? timelineY - zigzagOffset : timelineY + zigzagOffset;
      });

      // Position other nodes around their parent step (clustered)
      otherNodes.forEach(node => {
        // Find which step this node belongs to (via da:cellId)
        const cellId = node.properties['da:cellId'];
        const parentStep = stepNodes.find(s => s.id === cellId);
        if (parentStep) {
          // Cluster entities around parent step with radial offset
          const angle = Math.random() * Math.PI * 2;  // Random angle
          const distance = 80 + Math.random() * 100;  // Distance from step
          node.x = parentStep.fx + Math.cos(angle) * distance;
          node.y = parentStep.fy + Math.sin(angle) * distance;
        } else {
          // Orphan nodes use default positioning
          node.x = width/2 + (Math.random() - 0.5) * width * 0.5;
          node.y = height/2 + (Math.random() - 0.5) * height * 0.3;
        }
      });

      // Setup force simulation for ALL nodes (step nodes are pinned with fx/fy, so they won't move)
      const simulatedLinks = links.filter(l => {
        // Exclude nextItem links from force simulation
        const pred = l.predicate || l.type || '';
        return pred !== 'schema:nextItem';
      });

      simulation = d3.forceSimulation(nodes)  // All nodes, but step nodes are pinned
        .force('link', d3.forceLink(simulatedLinks).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-200))
        .force('y', d3.forceY(height / 2).strength(0.05))  // Gentle pull downward
        .force('collide', d3.forceCollide().radius(30));

      // Function to get link color based on relationship type
      const getLinkColor = d => {
        // Use d.predicate (full URI with prefix) instead of d.label (which has prefix stripped)
        const pred = d.predicate || d.type || '';

        // Highlight provenance/data flow relationships
        if (pred === 'prov:used') return '#2196F3';  // Blue: transformation uses data
        if (pred === 'prov:wasGeneratedBy') return '#7B1FA2';  // Purple: asset generated by transformation
        if (pred === 'prov:wasDerivedFrom') return '#4CAF50';  // Green: outcome derived from asset
        if (pred === 'da:performsTransformation') return '#FF6F00';  // Orange: cell performs transformation
        if (pred === 'da:produces') return '#4CAF50';  // Green: produces outcome
        if (pred === 'schema:nextItem') return '#FF0000';  // Bright RED: workflow sequence (very visible!)
        if (pred === 'dcterms:hasPart') return '#9E9E9E';  // Light gray: structural
        return '#BDBDBD';  // Default light gray for other relationships
      };

      const getLinkWidth = d => {
        // Use d.predicate for consistent checking
        const pred = d.predicate || d.type || '';

        // Make workflow sequence VERY prominent
        if (pred === 'schema:nextItem') return 8;  // Extra thick for visibility

        // Make provenance relationships thicker
        if (pred.startsWith('prov:')) return 2;
        if (pred === 'da:performsTransformation') return 2;
        if (pred === 'da:produces') return 2;
        return 1;
      };

      const getArrowMarker = d => {
        // Get the correct arrow marker based on predicate type
        const pred = d.predicate || d.type || '';
        const markerId = `arrow-${pred.replace(/[^a-zA-Z0-9]/g, '-')}`;
        // Check if marker exists, otherwise use default
        return pred && arrowColors[pred] ? `url(#${markerId})` : 'url(#arrow-default)';
      };

      // Draw stepped workflow rail connecting all steps (polyline for staircase effect)
      if (stepNodes.length > 1) {
        const railPoints = stepNodes.map(s => `${s.fx},${s.fy}`).join(' ');
        g.insert('polyline', ':first-child')
          .attr('class', 'timeline-rail')
          .attr('points', railPoints)
          .attr('fill', 'none')
          .attr('stroke', '#E0E0E0')
          .attr('stroke-width', 4)
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');
      }

      // Debug: Log nextItem links
      const nextItemLinks = links.filter(l => {
        const pred = l.predicate || l.type || '';
        return pred === 'schema:nextItem';
      });
      console.log('=== DEBUG INFO ===');
      console.log('Total links:', links.length);
      console.log('NextItem links found:', nextItemLinks.length);
      console.log('NextItem link details:', nextItemLinks);
      console.log('Sample link predicates:', links.slice(0, 10).map(l => l.predicate || l.type));
      console.log('Step nodes:', stepNodes.map(s => ({ id: s.id, label: s.label })));

      // Create links
      link = g.append('g')
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('class', d => `link-item link-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .attr('stroke', getLinkColor)
        .attr('stroke-width', getLinkWidth)
        .attr('stroke-opacity', d => {
          const pred = d.predicate || d.type || '';
          return pred === 'schema:nextItem' ? 1 : 0.6;  // Full opacity for nextItem
        })
        .attr('marker-end', getArrowMarker);

      // Link labels
      linkText = g.append('g')
        .selectAll('text')
        .data(links)
        .enter().append('text')
        .attr('class', d => `link-text-item link-text-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .attr('font-size', '8px')
        .attr('text-anchor', 'middle')
        .attr('dy', -3)
        .text(d => d.label);

      // Create nodes
      const getNodeColor = d => categoryColors[d.category] || categoryColors["default"];

      node = g.append('g')
        .selectAll('g')
        .data(nodes)
        .enter().append('g')
        .attr('class', d => `node-item node-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
        .call(d3.drag()
          .on('start', dragstart)
          .on('drag', dragging)
          .on('end', dragend))
        .on('click', showDetails)
        .on('mouseover', function(event, d) {
          // Highlight node contour
          d3.select(this).select('circle')
            .attr('stroke', '#e91e63')
            .attr('stroke-width', 2);

          // Highlight connected links
          const nodeId = d.id;
          link.filter(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === nodeId || targetId === nodeId;
          })
            .attr('stroke', '#e91e63')
            .attr('stroke-width', 2);

          linkText.filter(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            return sourceId === nodeId || targetId === nodeId;
          })
            .attr('font-weight', 'bold')
            .attr('fill', '#e91e63');

          // Show tooltip
          const tooltip = document.createElement('div');
          tooltip.className = 'node-tooltip';
          tooltip.id = 'active-tooltip';

          // Create header with title and type badge
          const header = document.createElement('div');
          header.className = 'header';

          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = d.label;

          const typeBadge = document.createElement('div');
          typeBadge.className = 'type-badge';
          typeBadge.textContent = d.type.split(':').pop();
          typeBadge.style.backgroundColor = categoryColors[d.category] || categoryColors["default"];

          header.appendChild(title);
          header.appendChild(typeBadge);

          const description = document.createElement('div');
          description.className = 'description';
          description.textContent = d.properties["dcterms:description"] || d.properties["d:description"] || d.properties["schema:description"] || d.properties["s:description"] || 'No description available';

          tooltip.appendChild(header);
          tooltip.appendChild(description);
          document.body.appendChild(tooltip);

          // Position tooltip near the node
          const nodeBox = this.getBoundingClientRect();
          const tooltipBox = tooltip.getBoundingClientRect();

          const top = nodeBox.top - tooltipBox.height - 10;
          const left = nodeBox.left + (nodeBox.width / 2) - (tooltipBox.width / 2);

          tooltip.style.top = `${Math.max(10, top)}px`;
          tooltip.style.left = `${Math.max(10, Math.min(window.innerWidth - tooltipBox.width - 10, left))}px`;
        })
        .on('mouseout', function(event, d) {
          // Remove node highlights
          d3.select(this).select('circle')
            .attr('stroke', null)
            .attr('stroke-width', null);

          // Restore original link colors/widths (not hardcoded gray!)
          link
            .attr('stroke', getLinkColor)
            .attr('stroke-width', getLinkWidth);

          linkText
            .attr('font-weight', 'normal')
            .attr('fill', '#666');

          // Remove tooltip
          const tooltip = document.getElementById('active-tooltip');
          if (tooltip) {
            tooltip.remove();
          }
        });

      // Render node circles with different sizes for steps vs other nodes
      node.append('circle')
        .attr('r', d => d.type === 'da:Cell' ? 24 : 8)  // Step nodes are larger
        .attr('fill', d => d.type === 'da:Cell' ? '#2c3e50' : getNodeColor(d))
        .attr('stroke', d => d.type === 'da:Cell' ? '#fff' : null)
        .attr('stroke-width', d => d.type === 'da:Cell' ? 3 : 0);

      // Add step number for Cell nodes
      node.filter(d => d.type === 'da:Cell')
        .append('text')
        .attr('class', 'step-number')
        .attr('text-anchor', 'middle')
        .attr('dy', 6)
        .attr('fill', 'white')
        .attr('font-size', '14px')
        .attr('font-weight', 'bold')
        .text(d => d.properties['da:executionOrder'] || '?');

      // Add step label below Cell nodes
      node.filter(d => d.type === 'da:Cell')
        .append('text')
        .attr('class', 'step-label')
        .attr('text-anchor', 'middle')
        .attr('y', 35)
        .attr('fill', '#2c3e50')
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .text(d => d.label);

      // Regular node labels (non-Cell nodes)
      node.filter(d => d.type !== 'da:Cell')
        .append('text')
        .attr('font-size', '10px')
        .attr('x', 10)
        .attr('dy', 4)
        .text(d => d.label);

      // Update positions on each simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        linkText
          .attr('x', d => (d.source.x + d.target.x)/2)
          .attr('y', d => (d.source.y + d.target.y)/2);

        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });

      // Create legend
      createLegend();

      document.getElementById('debug-info').textContent = `Visualization complete: ${nodes.length} entities, ${links.length} relationships`;
    }

    function createLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      // Add title
      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.style.marginBottom = '8px';
      title.style.fontSize = '13px';
      title.textContent = 'Knowledge Graph Legend';
      legend.appendChild(title);

      // Entity types section
      const entitiesTitle = document.createElement('div');
      entitiesTitle.style.fontWeight = 'bold';
      entitiesTitle.style.marginTop = '5px';
      entitiesTitle.style.marginBottom = '5px';
      entitiesTitle.style.fontSize = '11px';
      entitiesTitle.textContent = 'Entity Types:';
      legend.appendChild(entitiesTitle);

      const categories = [...new Set(nodes.map(n => n.category))].sort();

      categories.forEach(category => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = categoryColors[category] || categoryColors["default"];

        const label = document.createElement('div');
        label.textContent = category.split(':').pop();

        item.appendChild(colorBox);
        item.appendChild(label);
        legend.appendChild(item);
      });

      // Timeline workflow section
      const timelineTitle = document.createElement('div');
      timelineTitle.style.fontWeight = 'bold';
      timelineTitle.style.marginTop = '10px';
      timelineTitle.style.marginBottom = '5px';
      timelineTitle.style.fontSize = '11px';
      timelineTitle.textContent = 'Workflow Timeline:';
      legend.appendChild(timelineTitle);

      const timelineDesc = document.createElement('div');
      timelineDesc.style.fontSize = '10px';
      timelineDesc.style.marginBottom = '5px';
      timelineDesc.style.color = '#666';
      timelineDesc.textContent = 'Steps alternate up/down along horizontal timeline (zigzag)';
      legend.appendChild(timelineDesc);

      const timelineFlow = document.createElement('div');
      timelineFlow.className = 'legend-item';
      timelineFlow.style.fontSize = '11px';
      const timelineBox = document.createElement('div');
      timelineBox.style.width = '30px';
      timelineBox.style.height = '8px';
      timelineBox.style.backgroundColor = '#FF0000';  // Bright RED
      timelineBox.style.marginRight = '8px';
      const timelineLabel = document.createElement('div');
      timelineLabel.textContent = 'Step Sequence (8px thick)';
      timelineLabel.style.fontWeight = 'bold';
      timelineFlow.appendChild(timelineBox);
      timelineFlow.appendChild(timelineLabel);
      legend.appendChild(timelineFlow);

      // Data flow relationships section
      const flowTitle = document.createElement('div');
      flowTitle.style.fontWeight = 'bold';
      flowTitle.style.marginTop = '10px';
      flowTitle.style.marginBottom = '5px';
      flowTitle.style.fontSize = '11px';
      flowTitle.textContent = 'Data Flow:';
      legend.appendChild(flowTitle);

      const flows = [
        { color: '#2196F3', label: 'Uses Data', width: 2, desc: 'prov:used' },
        { color: '#7B1FA2', label: 'Generated By', width: 2, desc: 'prov:wasGeneratedBy' },
        { color: '#4CAF50', label: 'Derived From', width: 2, desc: 'prov:wasDerivedFrom' },
        { color: '#FF6F00', label: 'Transformation', width: 2, desc: 'da:performsTransformation' }
      ];

      flows.forEach(flow => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.style.fontSize = '11px';

        const colorBox = document.createElement('div');
        colorBox.style.width = '20px';
        colorBox.style.height = `${flow.width}px`;
        colorBox.style.backgroundColor = flow.color;
        colorBox.style.marginRight = '8px';

        const label = document.createElement('div');
        label.textContent = flow.label;
        label.title = flow.desc;

        item.appendChild(colorBox);
        item.appendChild(label);
        legend.appendChild(item);
      });
    }

    function populateEntityList() {
      const container = document.getElementById('entity-list');
      container.innerHTML = '';

      if (nodes.length === 0) {
        const noEntities = document.createElement('div');
        noEntities.textContent = "No entities to display";
        noEntities.style.padding = "10px";
        noEntities.style.color = "#888";
        container.appendChild(noEntities);
        return;
      }

      let filteredNodes = [...nodes];

      // Apply search filter
      if (searchQuery) {
        filteredNodes = filteredNodes.filter(n =>
          n.label.toLowerCase().includes(searchQuery.toLowerCase()) ||
          n.id.toLowerCase().includes(searchQuery.toLowerCase())
        );
      }

      // Apply type filter
      if (activeTypeFilters.size > 0) {
        filteredNodes = filteredNodes.filter(n => activeTypeFilters.has(n.type));
      }

      // Apply category filter
      if (activeCategoryFilters.size > 0) {
        filteredNodes = filteredNodes.filter(n => activeCategoryFilters.has(n.category));
      }

      filteredNodes.forEach(entity => {
        const div = document.createElement('div');
        div.className = 'entity-item';
        div.dataset.id = entity.id;
        div.innerHTML = `
          <strong>${entity.label}</strong>
          <div class="entity-type">${entity.type.split(':').pop()}</div>
        `;
        div.onclick = () => {
          document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('selected'));
          div.classList.add('selected');
          showDetails(null, entity);
          highlightConnections(entity);
        };
        container.appendChild(div);
      });
    }

    function updateFilters() {
      if (nodes.length === 0) {
        document.getElementById('type-filters').innerHTML = '<div>No data available</div>';
        document.getElementById('category-filters').innerHTML = '<div>No data available</div>';
        document.getElementById('relationship-filters').innerHTML = '<div>No data available</div>';
        return;
      }

      const types = [...new Set(nodes.map(n => n.type))];
      const categories = [...new Set(nodes.map(n => n.category))];
      const relationshipTypes = [...new Set(links.map(l => l.type))];

      // Populate type filters
      const typeFilters = document.getElementById('type-filters');
      typeFilters.innerHTML = '';
      types.forEach(type => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = type.split(':').pop();
        filter.dataset.value = type;
        if (activeTypeFilters.has(type)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeTypeFilters.add(type);
          } else {
            activeTypeFilters.delete(type);
          }
          populateEntityList();
        };
        typeFilters.appendChild(filter);
      });

      // Populate category filters
      const categoryFilters = document.getElementById('category-filters');
      categoryFilters.innerHTML = '';
      categories.forEach(category => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = category.split(':').pop();
        filter.dataset.value = category;
        filter.style.backgroundColor = categoryColors[category] || '#888';
        filter.style.color = 'white';
        if (activeCategoryFilters.has(category)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeCategoryFilters.add(category);
          } else {
            activeCategoryFilters.delete(category);
          }
          populateEntityList();
        };
        categoryFilters.appendChild(filter);
      });

      // Populate relationship filters
      const relationshipFilters = document.getElementById('relationship-filters');
      relationshipFilters.innerHTML = '';
      relationshipTypes.forEach(type => {
        const filter = document.createElement('div');
        filter.className = 'filter-option';
        filter.textContent = type.split(':').pop();
        filter.dataset.value = type;
        if (activeRelationshipFilters.has(type)) {
          filter.classList.add('active');
        }
        filter.onclick = function() {
          this.classList.toggle('active');
          if (this.classList.contains('active')) {
            activeRelationshipFilters.add(type);
          } else {
            activeRelationshipFilters.delete(type);
          }
          highlightRelationshipsByType();
        };
        relationshipFilters.appendChild(filter);
      });
    }

    function highlightRelationshipsByType() {
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');

      if (activeRelationshipFilters.size === 0) {
        return;
      }

      link.filter(l => activeRelationshipFilters.has(l.type))
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);

      linkText.filter(l => activeRelationshipFilters.has(l.type))
        .attr('font-weight', 'bold')
        .attr('fill', '#e91e63');
    }

    function updateStatistics() {
      const container = document.getElementById('stats-container');
      container.innerHTML = '';

      const title = document.createElement('h3');
      title.textContent = 'Graph Statistics';
      container.appendChild(title);

      if (nodes.length === 0 || links.length === 0) {
        const noData = document.createElement('p');
        noData.textContent = 'No data available for statistics';
        container.appendChild(noData);
        return;
      }

      // Entity count by category
      const categoryTitle = document.createElement('h4');
      categoryTitle.textContent = 'Entities by Category';
      container.appendChild(categoryTitle);

      const categoryStats = {};
      nodes.forEach(node => {
        categoryStats[node.category] = (categoryStats[node.category] || 0) + 1;
      });

      Object.entries(categoryStats).forEach(([category, count]) => {
        const div = document.createElement('div');
        div.className = 'category-count';
        div.innerHTML = `
          <span>${category.split(':').pop()}:</span>
          <span>${count}</span>
        `;
        container.appendChild(div);
      });

      // Relationship count by type
      const relationshipTitle = document.createElement('h4');
      relationshipTitle.textContent = 'Relationships by Type';
      container.appendChild(relationshipTitle);

      const relationshipStats = {};
      links.forEach(link => {
        relationshipStats[link.type] = (relationshipStats[link.type] || 0) + 1;
      });

      Object.entries(relationshipStats).forEach(([type, count]) => {
        const div = document.createElement('div');
        div.className = 'category-count';
        div.innerHTML = `
          <span>${type.split(':').pop()}:</span>
          <span>${count}</span>
        `;
        container.appendChild(div);
      });

      // Total counts and extraction metadata
      const summary = document.createElement('div');
      summary.className = 'summary';
      let summaryHTML = `
        <strong>Total Entities:</strong> ${nodes.length}<br>
        <strong>Total Relationships:</strong> ${links.length}
      `;

      // Add extraction metadata if available
      if (knowledgeGraph && knowledgeGraph.extractionMetadata) {
        const metadata = knowledgeGraph.extractionMetadata;
        summaryHTML += `<br><br><strong>Extraction Info:</strong><br>`;

        if (metadata.verificationConfidence !== undefined) {
          summaryHTML += `Verification Confidence: ${(metadata.verificationConfidence * 100).toFixed(1)}%<br>`;
        }

        if (metadata.extractorVersion) {
          summaryHTML += `Extractor: ${metadata.extractorVersion}<br>`;
        }

        // Handle deduplication summary (can be string or object)
        if (metadata.deduplicationSummary) {
          if (typeof metadata.deduplicationSummary === 'object') {
            const dedup = metadata.deduplicationSummary;
            summaryHTML += `Deduplication: ${dedup.merged} merged, ${dedup.created} created<br>`;
          } else {
            summaryHTML += `Deduplication: ${metadata.deduplicationSummary}<br>`;
          }
        }
      }

      // Add source information
      if (knowledgeGraph && (knowledgeGraph["dcterms:source"] || knowledgeGraph["dcterms:created"])) {
        summaryHTML += `<br><strong>Source:</strong><br>`;
        if (knowledgeGraph["dcterms:source"]) {
          summaryHTML += `File: ${knowledgeGraph["dcterms:source"]}<br>`;
        }
        if (knowledgeGraph["dcterms:created"]) {
          const date = new Date(knowledgeGraph["dcterms:created"]);
          summaryHTML += `Created: ${date.toLocaleString()}<br>`;
        }
      }

      summary.innerHTML = summaryHTML;
      container.appendChild(summary);
    }

    function handleSearch(event) {
      searchQuery = event.target.value;
      populateEntityList();
    }

    function clearAllFilters() {
      activeTypeFilters.clear();
      activeCategoryFilters.clear();
      activeRelationshipFilters.clear();
      searchQuery = '';
      document.getElementById('search-box').value = '';

      document.querySelectorAll('.filter-option').forEach(el => {
        el.classList.remove('active');
      });

      populateEntityList();

      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');

      showStatusMessage("All filters cleared", "info");
    }

    function showDetails(event, d) {
      const detailsTitle = document.getElementById('details-title');
      const detailsType = document.getElementById('details-type');
      const detailsContent = document.getElementById('details-content');

      detailsTitle.textContent = d.label;
      detailsType.textContent = d.type.split(':').pop();
      detailsContent.innerHTML = '';

      // Show description if available (support both abbreviated and full prefixes)
      const description = d.properties["dcterms:description"] || d.properties["d:description"] ||
                          d.properties["schema:description"] || d.properties["s:description"];
      if (description) {
        const summary = document.createElement('div');
        summary.className = 'summary';
        summary.textContent = description;
        detailsContent.appendChild(summary);
      }

      // Show the entity ID
      const idProperty = document.createElement('div');
      idProperty.className = 'property';
      idProperty.innerHTML = `
        <div class="property-name">ID:</div>
        <div class="property-value">${d.id}</div>
      `;
      detailsContent.appendChild(idProperty);

      // Show confidence if available
      if (d.properties.confidence !== undefined) {
        const confidenceProperty = document.createElement('div');
        confidenceProperty.className = 'property';
        confidenceProperty.innerHTML = `
          <div class="property-name">Confidence:</div>
          <div class="property-value">${(d.properties.confidence * 100).toFixed(1)}%</div>
        `;
        detailsContent.appendChild(confidenceProperty);
      }

      // Show semantic type with proper formatting
      if (d.type !== d.properties["@type"]) {
        const typeProperty = document.createElement('div');
        typeProperty.className = 'property';
        typeProperty.innerHTML = `
          <div class="property-name">Semantic Type:</div>
          <div class="property-value">${d.properties["@type"] || d.type}</div>
        `;
        detailsContent.appendChild(typeProperty);
      }

      // Show aliases if available (support both abbreviated and full prefixes)
      const altLabel = d.properties["skos:altLabel"] || d.properties["sk:altLabel"];
      if (altLabel) {
        const aliasProperty = document.createElement('div');
        aliasProperty.className = 'property';
        const aliases = Array.isArray(altLabel)
          ? altLabel.join(', ')
          : altLabel;
        aliasProperty.innerHTML = `
          <div class="property-name">Aliases:</div>
          <div class="property-value">${aliases}</div>
        `;
        detailsContent.appendChild(aliasProperty);
      }

      // Show connected relationships
      const relatedTitle = document.createElement('h4');
      relatedTitle.textContent = 'Connected Relationships';
      detailsContent.appendChild(relatedTitle);

      const connectedLinks = links.filter(l =>
        (typeof l.source === 'object' ? l.source.id === d.id : l.source === d.id) ||
        (typeof l.target === 'object' ? l.target.id === d.id : l.target === d.id)
      );

      if (connectedLinks.length > 0) {
        connectedLinks.forEach(link => {
          const relationshipDiv = document.createElement('div');
          relationshipDiv.className = 'relationship-detail';

          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;

          const sourceName = entities[sourceId].label;
          const targetName = entities[targetId].label;

          // Use the predicate/label from the link object (already extracted from s:name)
          const predicate = link.predicate || link.label || 'related';

          relationshipDiv.innerHTML = `
            <strong>${sourceName}</strong> ‚Üí
            <em>${predicate}</em> ‚Üí
            <strong>${targetName}</strong>
          `;

          // Support both abbreviated and full prefixes for description
          const relDescription = link.properties && (link.properties["dcterms:description"] || link.properties["d:description"] ||
                                                      link.properties["schema:description"] || link.properties["s:description"]);
          if (relDescription) {
            const descDiv = document.createElement('div');
            descDiv.style.fontSize = '12px';
            descDiv.style.marginTop = '5px';
            descDiv.textContent = relDescription;
            relationshipDiv.appendChild(descDiv);
          }

          detailsContent.appendChild(relationshipDiv);
        });
      } else {
        const noRelationships = document.createElement('div');
        noRelationships.className = 'property-value';
        noRelationships.textContent = 'No connected relationships found.';
        detailsContent.appendChild(noRelationships);
      }
    }

    function highlightConnections(d) {
      node.selectAll('circle').attr('r', 8).attr('stroke', null);
      link.attr('stroke', '#999').attr('stroke-width', 1);
      linkText.attr('font-weight', 'normal').attr('fill', '#666');

      const nodeId = d.id;
      const connectedLinks = links.filter(l =>
        (typeof l.source === 'object' ? l.source.id === nodeId : l.source === nodeId) ||
        (typeof l.target === 'object' ? l.target.id === nodeId : l.target === nodeId)
      );

      const connectedNodes = new Set([nodeId]);
      connectedLinks.forEach(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        connectedNodes.add(sourceId);
        connectedNodes.add(targetId);
      });

      // Highlight the node
      node.filter(n => n.id === nodeId)
        .select('circle')
        .attr('r', 12)
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);

      // Highlight connected nodes
      node.filter(n => connectedNodes.has(n.id) && n.id !== nodeId)
        .select('circle')
        .attr('r', 10)
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 1);

      // Highlight links
      link.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === nodeId || targetId === nodeId;
      })
        .attr('stroke', '#e91e63')
        .attr('stroke-width', 2);

      linkText.filter(l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        return sourceId === nodeId || targetId === nodeId;
      })
        .attr('font-weight', 'bold')
        .attr('fill', '#e91e63');
    }

    // Zoom functions
    function zoomIn() {
      if (svg) {
        svg.transition().call(zoom.scaleBy, 1.3);
      }
    }

    function zoomOut() {
      if (svg) {
        svg.transition().call(zoom.scaleBy, 0.7);
      }
    }

    function resetZoom() {
      if (svg) {
        svg.transition().call(zoom.transform, d3.zoomIdentity);
      }
    }

    // Drag functions
    function dragstart(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragging(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragend(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function exportData() {
      if (!knowledgeGraph) {
        showStatusMessage("No data to export", "error");
        return;
      }

      const dataStr = JSON.stringify(knowledgeGraph, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

      const exportFileName = 'knowledge-graph-export.json';

      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileName);
      linkElement.click();
    }

    function showStatusMessage(message, type = 'info') {
      const statusElement = document.getElementById('status-message');
      statusElement.textContent = message;
      statusElement.style.backgroundColor = type === 'error' ? '#f44336' : '#4CAF50';
      statusElement.style.display = 'block';

      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 3000);
    }
  </script>
</body>
</html>